
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>eastwest.gpx</title>
    <style>
        body { font-family: sans-serif; }
        canvas { }
        #itineraryTable th {
            position: sticky;
            top: 0;
            background-color: #f2f2f2; /* Add a background to prevent content from showing through */
            z-index: 1; /* Ensure it stays on top of scrolling content */
        }
        .current-position-row {
            font-weight: bold;
            color: red;
        }
        #itineraryTable th:nth-child(4),
        #itineraryTable td:nth-child(4),
        #itineraryTable th:nth-child(5),
        #itineraryTable td:nth-child(5) {
            display: none;
        }
        #itineraryTable {
        }
        #itineraryTable th {
            font-size: 2em;
        }
        #itineraryTable td {
            font-size: 3em;
        }
    </style>
</head>
<body>
    <button id="refreshButton" style="position: absolute; top: 10px; right: 10px; z-index: 10; font-size: 2em; padding: 10px; border-radius: 5px;">Refresh GPS</button>
    <div id="gpsStatus" style="position: absolute; top: 80px; right: 10px; z-index: 10; font-size: 2em;"></div>
    <canvas id="profileCanvas" style="width: 100%; height: 33vh;"></canvas>
    <script>
        window.addEventListener('load', function() {
            const canvas = document.getElementById('profileCanvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            const elevations = [74.0, 74.0, 74.0, 74.0, 74.0, 75.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 76.0, 76.0, 75.0, 75.0, 75.0, 75.0, 75.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 76.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0, 77.0];
            const distances = [0, 0.0009044820422558732, 0.011973404986654742, 0.02379692472444283, 0.02759565961718575, 0.06245766714085078, 0.09778819829186387, 0.12285732857349951, 0.13871527286179988, 0.14546617263447725, 0.1479714971186628, 0.1504107032329649, 0.15648899136412814, 0.16801647926002158, 0.17963814534881237, 0.18335805210610479, 0.1851371709326664, 0.1913736701250472, 0.19588547282598276, 0.20019646077138603, 0.21492245847319302, 0.22002479417277343, 0.22435153155541848, 0.23172170113582397, 0.2330243483579799, 0.23523884882006715, 0.24005632292494816, 0.24385505866628793, 0.24691440672991066, 0.2854833828283056, 0.3232629481839071, 0.36106235864367253, 0.37782280999373624, 0.38449604408062965, 0.40005636248667237, 0.4149163312907369, 0.4436010521661079, 0.45785901399162016, 0.4714489669112916, 0.49133349986919433, 0.5111513587771891, 0.5154624020475818, 0.5212396507387939, 0.5794378462897825, 0.6383791419113141, 0.6426902057363331, 0.6457940232446602, 0.6898015095883548, 0.6917513747060483, 0.6967879495849553, 0.7016518626426116, 0.7364305338115609, 0.7668480661273969, 0.7793051522960521, 0.7917622444343813, 0.8387103638959847, 0.8462744786929556, 0.8548966552321181];
            const lats = [52.3921, 52.392094, 52.39211, 52.392127, 52.392116, 52.392133, 52.392149, 52.39216, 52.392171, 52.392165, 52.39216, 52.392155, 52.392133, 52.392078, 52.392182, 52.392215, 52.392231, 52.392286, 52.392275, 52.39227, 52.392248, 52.392237, 52.392231, 52.392165, 52.392155, 52.392138, 52.392105, 52.392116, 52.392122, 52.392056, 52.391996, 52.391935, 52.391908, 52.391913, 52.391886, 52.391864, 52.391809, 52.391787, 52.391765, 52.391732, 52.391699, 52.391694, 52.391678, 52.391585, 52.391485, 52.39148, 52.391475, 52.391404, 52.391398, 52.391387, 52.391381, 52.391321, 52.391272, 52.39125, 52.391228, 52.391157, 52.391223, 52.391233];
            const lons = [16.977611, 16.97762, 16.977781, 16.977953, 16.978006, 16.978519, 16.979039, 16.979408, 16.979641, 16.97974, 16.979776, 16.979811, 16.979893, 16.980037, 16.980054, 16.980045, 16.980045, 16.980063, 16.980127, 16.98019, 16.980404, 16.980477, 16.98054, 16.98053, 16.98054, 16.980557, 16.980603, 16.980656, 16.9807, 16.981258, 16.981806, 16.982354, 16.982597, 16.982695, 16.98292, 16.983136, 16.983549, 16.983756, 16.983953, 16.984241, 16.984528, 16.984591, 16.984672, 16.985516, 16.986369, 16.986432, 16.986477, 16.987115, 16.987142, 16.987214, 16.987285, 16.987788, 16.988229, 16.988409, 16.988589, 16.989271, 16.989298, 16.989172];
            const importantPointsData = [];
            const minLat = 52.391157;
            const maxLat = 52.392286;
            const minLon = 16.977611;
            const maxLon = 16.989298;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const paddingTop = 60;
            const paddingRight = 0;
            const paddingBottom = 40;
            const paddingLeft = 80;

            const maxEle = Math.max(...elevations);
            const minEle = Math.min(...elevations);
            const eleRange = maxEle - minEle;
            const maxDist = distances[distances.length - 1];

            let lastRefreshTime;

            function getX(distance) {
                return paddingLeft + (distance / maxDist) * (width - paddingLeft - paddingRight);
            }

            function getY(elevation) {
                return height - paddingBottom - ((elevation - minEle) / eleRange) * (height - paddingTop - paddingBottom);
            }

            function drawProfile() {
                ctx.clearRect(0, 0, width, height);
                // Draw profile
                ctx.beginPath();
                ctx.moveTo(getX(distances[0]), getY(elevations[0]));
                for (let i = 1; i < elevations.length; i++) {
                    ctx.lineTo(getX(distances[i]), getY(elevations[i]));
                }
                ctx.stroke();

                // Draw axes
                ctx.beginPath();
                ctx.moveTo(paddingLeft, paddingTop);
                ctx.lineTo(paddingLeft, height - paddingBottom);
                ctx.lineTo(width - paddingRight, height - paddingBottom);
                ctx.stroke();

                // Draw labels
                ctx.fillStyle = 'black';
                ctx.font = '35px Arial'; // Set a much bigger font
                ctx.textAlign = 'left';
                ctx.fillText(maxEle.toFixed(0) + ' m', 5, paddingTop + 5);
                ctx.fillText(minEle.toFixed(0) + ' m', 5, height - paddingBottom);

                // Draw y-axis label
                ctx.save();
                ctx.translate(60, height / 2); // Translate to the position where the text will be drawn
                ctx.rotate(-Math.PI / 2); // Rotate -90 degrees (counter-clockwise)
                ctx.textAlign = 'center'; // Center the text horizontally after rotation
                ctx.fillText('Elevation', 0, 0); // Draw text at the new origin
                ctx.restore(); // Restore the canvas to its original state

                ctx.textAlign = 'center';
                ctx.fillText('Distance', width / 2, height - paddingBottom + 30);
                ctx.textAlign = 'left';
                ctx.fillText('0 km', paddingLeft, height - paddingBottom + 30);
                ctx.textAlign = 'right';
                ctx.textAlign = 'right';
                ctx.fillText(maxDist.toFixed(1) + ' km', width - paddingRight, height - paddingBottom + 30);
            }

            drawProfile();

            function haversine(lat1, lon1, lat2, lon2) {
                const R = 6371; // Radius of Earth in kilometers
                const dLat = (lat2 - lat1) * Math.PI / 180;  // deg2rad below
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = 
                    0.5 - Math.cos(dLat)/2 + 
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                    (1 - Math.cos(dLon))/2;

                return R * 2 * Math.asin(Math.sqrt(a));
            }

            function calculateBearing(startLat, startLng, destLat, destLng) {
              // Convert degrees to radians
              const toRadians = (degrees) => degrees * Math.PI / 180;
              const toDegrees = (radians) => radians * 180 / Math.PI;

              const startLatRad = toRadians(startLat);
              const startLngRad = toRadians(startLng);
              const destLatRad = toRadians(destLat);
              const destLngRad = toRadians(destLng);

              // Calculate the difference in longitude
              const deltaLng = destLngRad - startLngRad;

              // Calculate the bearing
              const y = Math.sin(deltaLng) * Math.cos(destLatRad);
              const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                        Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(deltaLng);
              let bearing = Math.atan2(y, x);

              // Convert the bearing from radians to degrees
              bearing = toDegrees(bearing);

              // Ensure the bearing is a positive number between 0 and 360
              return (bearing + 360) % 360;
            }

            function getBearingArrow(bearing) {
                if (bearing >= 337.5 || bearing < 22.5) {
                    return '↑'; // North
                } else if (bearing >= 22.5 && bearing < 67.5) {
                    return '↗'; // North-East
                } else if (bearing >= 67.5 && bearing < 112.5) {
                    return '→'; // East
                } else if (bearing >= 112.5 && bearing < 157.5) {
                    return '↘'; // South-East
                } else if (bearing >= 157.5 && bearing < 202.5) {
                    return '↓'; // South
                } else if (bearing >= 202.5 && bearing < 247.5) {
                    return '↙'; // South-West
                } else if (bearing >= 247.5 && bearing < 292.5) {
                    return '←'; // West
                } else if (bearing >= 292.5 && bearing < 337.5) {
                    return '↖'; // North-West
                }
                return ''; // Should not happen
            }

            function sortTable() {
                const tableBody = document.querySelector('#itineraryTable tbody');
                const rows = Array.from(tableBody.children);

                rows.sort((a, b) => {
                    const distanceA = parseFloat(a.cells[0].textContent.trim());
                    const distanceB = parseFloat(b.cells[0].textContent.trim());

                    if (isNaN(distanceA) && isNaN(distanceB)) return 0; // Both NaN, keep original order
                    if (isNaN(distanceA)) return 1; // A is NaN, B is a number, put A at the end
                    if (isNaN(distanceB)) return -1; // B is NaN, A is a number, put B at the end

                    return distanceA - distanceB;
                });

                while (tableBody.firstChild) {
                    tableBody.removeChild(tableBody.firstChild);
                }
                rows.forEach(row => tableBody.appendChild(row));
            }

            function updateStaticTable() {
                const maxEleIndex = elevations.indexOf(maxEle);
                const maxEleDistance = distances[maxEleIndex];

                document.getElementById('startDistance').innerText = distances[0].toFixed(1);
                document.getElementById('startHeight').innerText = elevations[0].toFixed(0);

                document.getElementById('highestPointDistance').innerText = maxEleDistance.toFixed(1);
                document.getElementById('highestPointHeight').innerText = maxEle.toFixed(0);

                document.getElementById('finishDistance').innerText = maxDist.toFixed(1);
                document.getElementById('finishHeight').innerText = elevations[elevations.length - 1].toFixed(0);

                document.getElementById('startLat').innerText = lats[0].toFixed(5);
                document.getElementById('startLon').innerText = lons[0].toFixed(5);

                document.getElementById('highestPointLat').innerText = lats[maxEleIndex].toFixed(5);
                document.getElementById('highestPointLon').innerText = lons[maxEleIndex].toFixed(5);

                document.getElementById('finishLat').innerText = lats[lats.length - 1].toFixed(5);
                document.getElementById('finishLon').innerText = lons[lons.length - 1].toFixed(5);
                sortTable();
            }

            function formatTimeAgo(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) {
                    return Math.floor(interval) + " years ago";
                }
                interval = seconds / 2592000;
                if (interval > 1) {
                    return Math.floor(interval) + " months ago";
                }
                interval = seconds / 86400;
                if (interval > 1) {
                    return Math.floor(interval) + " days ago";
                }
                interval = seconds / 3600;
                if (interval > 1) {
                    return Math.floor(interval) + " hours ago";
                }
                interval = seconds / 60;
                if (interval > 1) {
                    return Math.floor(interval) + " minutes ago";
                }
                return Math.floor(seconds) + " seconds ago";
            }

            function refreshLocation() {
                let dots = 0;
                const interval = setInterval(() => {
                    dots = (dots + 1) % 4;
                    document.getElementById('gpsStatus').innerText = ".".repeat(dots);
                }, 500);

                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(position => {
                        clearInterval(interval);
                        lastRefreshTime = new Date();
                        const userLat = position.coords.latitude;
                        const userLon = position.coords.longitude;
                        document.getElementById('gpsStatus').innerText = `Lat: ${userLat.toFixed(5)}, Lon: ${userLon.toFixed(5)}`;
        
                        console.log('User Location:', userLat, userLon);
        
                        let nearestIndex = 0;
                        let minDistance = Infinity;
                        for (let i = 0; i < lats.length; i++) {
                            const dist = haversine(userLat, userLon, lats[i], lons[i]);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestIndex = i;
                            }
                        }
                        console.log('Nearest Index:', nearestIndex, 'Min Distance:', minDistance);
                        updateMapAndTable(nearestIndex, userLat, userLon);
                    }, error => {
                        clearInterval(interval);
                        document.getElementById('gpsStatus').innerText = 'NOPE';
                        console.error('Error getting user location:', error);
                    });
                } else {
                    clearInterval(interval);
                    document.getElementById('gpsStatus').innerText = 'NOPE';
                    console.error('Geolocation is not supported by this browser.');
                }
            }

            updateStaticTable();
            refreshLocation();

            document.getElementById('refreshButton').addEventListener('click', refreshLocation);

            setInterval(() => {
                if (lastRefreshTime) {
                    document.getElementById('gpsStatus').innerText = formatTimeAgo(lastRefreshTime);
                }
            }, 1000);

            function updateMapAndTable(nearestIndex, actualLat, actualLon) {
                drawProfile();
                document.getElementById('currentPositionRow').style.display = '';
                console.log('Nearest Index:', nearestIndex);

                // Draw current position line
                const currentX = getX(distances[nearestIndex]);
                ctx.beginPath();
                ctx.strokeStyle = 'red';
                ctx.moveTo(currentX, paddingTop);
                ctx.lineTo(currentX, height - paddingBottom);
                ctx.stroke();

                // Draw info on top of the line
                const currentDist = distances[nearestIndex];
                const percentage = (currentDist / maxDist) * 100;
                const ele = elevations[nearestIndex];
                ctx.fillStyle = 'red';
                ctx.font = '35px Arial'; // Set a much bigger font for current position info

                let textX = currentX;
                if (currentX < paddingLeft + 50) {
                    ctx.textAlign = 'left';
                    textX = paddingLeft;
                } else if (currentX > width - paddingRight - 50) {
                    ctx.textAlign = 'right';
                    textX = width - paddingRight;
                } else {
                    ctx.textAlign = 'center';
                }

                ctx.fillText(ele.toFixed(0) + ' m', textX, paddingTop - 30);
                ctx.fillText(currentDist.toFixed(1) + ' km (' + percentage.toFixed(0) + '%)', textX, paddingTop - 5);

                const tableBody = document.querySelector('#itineraryTable tbody');

                document.getElementById('currentDistance').innerText = currentDist.toFixed(1);
                document.getElementById('currentHeight').innerText = ele.toFixed(0);
                document.getElementById('currentLat').innerText = lats[nearestIndex].toFixed(5);
                document.getElementById('currentLon').innerText = lons[nearestIndex].toFixed(5);

                const maxEleIndex = elevations.indexOf(maxEle);

                const currentLat = actualLat;
                const currentLon = actualLon;

                const startBearing = calculateBearing(currentLat, currentLon, lats[0], lons[0]);
                const highestPointBearing = calculateBearing(currentLat, currentLon, lats[maxEleIndex], lons[maxEleIndex]);
                const finishBearing = calculateBearing(currentLat, currentLon, lats[lats.length - 1], lons[lats.length - 1]);

                document.getElementById('startDistFromCurrent').innerText = haversine(currentLat, currentLon, lats[0], lons[0]).toFixed(1) + ' km ' + getBearingArrow(startBearing);
                document.getElementById('currentDistFromCurrent').innerText = '';
                document.getElementById('highestPointDistFromCurrent').innerText = haversine(currentLat, currentLon, lats[maxEleIndex], lons[maxEleIndex]).toFixed(1) + ' km ' + getBearingArrow(highestPointBearing);
                document.getElementById('finishDistFromCurrent').innerText = haversine(currentLat, currentLon, lats[lats.length - 1], lons[lats.length - 1]).toFixed(1) + ' km ' + getBearingArrow(finishBearing);

                importantPointsData.forEach((point, index) => {
                    const dist = haversine(currentLat, currentLon, point.lat, point.lon);
                    const bearing = calculateBearing(currentLat, currentLon, point.lat, point.lon);
                    document.getElementById(`importantPointDistFromCurrent_${index}`).innerText = dist.toFixed(1) + ' km ' + getBearingArrow(bearing);
                });

                sortTable();

                // Scroll to current position
                const tableContainer = document.getElementById('tableContainer');
                const currentPositionRow = document.getElementById('currentDistance').closest('tr'); // Find the parent <tr>

                if (tableContainer && currentPositionRow) {
                    currentPositionRow.scrollIntoView({ block: "center" });
                    currentPositionRow.classList.add('current-position-row');
                }
            }
            // Calculate remaining height for tableContainer
            const canvasHeight = document.getElementById('profileCanvas').offsetHeight;

            const totalOccupiedHeight = canvasHeight;
            const windowHeight = window.innerHeight;
            const remainingHeight = windowHeight - totalOccupiedHeight - 25;

            if (tableContainer) {
                tableContainer.style.height = `${remainingHeight}px`;
            }
    });
    </script>
    <div id="tableContainer" style="height: 200px; overflow-y: scroll;">
        <table border="1" width="100%" id="itineraryTable">
            <thead>
                <tr>
                    <th>Distance (km)</th>
                    <th>Height (m)</th>
                    <th>Point</th>
                    <th>Lat</th>
                    <th>Lon</th>
                    <th>From Current (km)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td id="startDistance"></td>
                    <td id="startHeight"></td>
                    <td>START</td>
                    <td id="startLat"></td>
                    <td id="startLon"></td>
                    <td id="startDistFromCurrent"></td>
                </tr>
                <tr id="currentPositionRow" style="display: none;">
                    <td id="currentDistance"></td>
                    <td id="currentHeight"></td>
                    <td>Current Position</td>
                    <td id="currentLat"></td>
                    <td id="currentLon"></td>
                    <td id="currentDistFromCurrent"></td>
                </tr>
                <tr>
                    <td id="highestPointDistance"></td>
                    <td id="highestPointHeight"></td>
                    <td>Highest Point</td>
                    <td id="highestPointLat"></td>
                    <td id="highestPointLon"></td>
                    <td id="highestPointDistFromCurrent"></td>
                </tr>
                <tr>
                    <td id="finishDistance"></td>
                    <td id="finishHeight"></td>
                    <td>FINISH</td>
                    <td id="finishLat"></td>
                    <td id="finishLon"></td>
                    <td id="finishDistFromCurrent"></td>
                </tr>
                
            </tbody>
        </table>
    </div>
</body>
</html>

